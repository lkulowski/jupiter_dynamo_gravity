# Author: Laura Kulowski

'''

Calculate the density perturbation and gravity signal (i.e., odd zonal gravity harmonics)
associated with a zonal wind profile

'''

import numpy as np
from scipy import interpolate
from scipy.integrate import simps

class Gravity_Calc():
    
    def __init__(self, u_phi, grid, density_model = 'ab_int', save_folder = None):

        '''
        : param u_phi:           zonal wind profile; np.array of shape (nt, nr + 1)
        : param grid:            grid object generated by Grid class 
        : param density_model:   Jupiter interior density model;
        :                        'ab_int' for density model produced by ab initio simulations
        :                        'ppt' for density model assuming a discontinuous transition from molecular
        :                         to liquid metallic hydrogen(i.e., plasma phase transition)
        :                        'no_core' for density model assuming there is no core at Jupiter's center
        : param r_outer: outer boundary of the radial grid (<= 1)
        '''

        self.u_phi = u_phi
        self.grid = grid
        self.density_model = density_model

        # grid dimensions
        self.nr = self.grid.nr
        self.nt = self.grid.nt
        self.r_inner = self.grid.r_inner
        self.r_outer = self.grid.r_outer

        # r, theta grid
        self.rc = self.grid.cgl_points()
        self.rcs = self.grid.cheby_shift()
        theta, lats_gl = self.grid.theta_lat_grids()
        self.theta = theta
        self.leg_deg = self.nt                                                     # maximum degree for spherical harmonic
                                                                                   # expansions 
        # cheby/leg weights; leg points 
        self.wr = self.grid.cheby_wr()
        self.xl, self.w = self.grid.gauss_leg_xw()

        # cheby differentiation matrix
        self.Dm = self.grid.cheby_diff_matrix()

        # legendre polynomials + derivatives
        self.p = self.grid.leg_P()
        self.dp_dz, self.dp_dtheta = self.grid.leg_P_deriv() 

        # physical constants
        self.G = 6.674 * 10.**-11                                                  # gravitational constant (m^3 kg^-1 s^-2) 
        self.M = 1.89819 * 10.**27                                                 # Jupiter's mass (kg)
        self.R_vol = 69911. * 10.**3                                               # Jupiter's volumetric radius (m)
        self.a = 71492. * 10.**3                                                   # Jupiter's equatorial radius,
                                                                                   #     for Jn calculation (m)
        self.L = self.R_vol                                                        # nondimensional length scale (m) 

        self.T = 9.925 * 60.**2                                                    # Jupiter's rotation period (s)
        self.Omega0 = 2. * np.pi / self.T                                          # Jupiter's angular velocity (rad/s)

        if save_folder:
            self.save_folder = save_folder 

    def background_state(self):
        
        '''
        interpolate the density and effective gravity associated with Jupiter's hydrostatic state onto the grid  
        : return rho0:            background density, function of r only; shape (1, nr + 1)
        : return dro0_dr:         radial derivative of background density, function of r only; shape (1, nr + 1) 
        : return rho0_matrix:     background density evaluated on r-theta grid; shape (nt, nr + 1)
        : return g_eff:           effective gravity, function of r only; shape (1, nr + 1)
        '''
        
        # load interior modal data (r-position, density, mass)
        file_data = "../data/density_profiles/"
        arr_r = np.load(file_data + "arr_r_" + self.density_model + ".npy")
        arr_rho = np.load(file_data + "arr_rho_" + self.density_model + ".npy")
        arr_M = np.load(file_data + "arr_M_" + self.density_model + ".npy")

        # interpolate density and effective gravity onto grid  
        interp_density = interpolate.interp1d(arr_r, arr_rho, kind = 'linear')
        interp_grav = interpolate.interp1d(arr_r, arr_M, kind = "linear")

        rho0 = interp_density(self.rcs)
        arr_m = interp_grav(self.rcs)
        g_eff = - self.G * arr_m / (self.L * self.rcs)**2

        # calculate radial derivative of density
        drho0_dr = (1./self.L) * np.dot(self.Dm, rho0)

        # density on r-theta grid (convenient for later calculations)
        rho0_matrix = np.zeros([self.nt, self.nr + 1])
        for tt in np.arange(self.nt):
            rho0_matrix[tt, :] = rho0

        return rho0, drho0_dr, rho0_matrix, g_eff
        
    def field_phys2spec(self, field):

        '''
        transform a field from physical space to spectral space; we expand the function f(r, theta) so that
        f(r, theta) = sum_{n = 0}^{N_max} f_n(r) * P_n(cos(theta))
        : param field:             physical field; shape (nt, nr + 1)
        : return field_spec_n:     f_n(r); shape (max deg + 1, nr + 1) 
        '''
        
        field_spec_n = np.zeros([self.leg_deg + 1, self.nr + 1])

        for rr in range(self.nr + 1):
            for nn in range(self.leg_deg + 1):
                ff = field[:, rr] * self.p[nn, :]
                field_nn = (2. * nn + 1.) / 2. * np.dot(self.w, ff)

                if abs(field_nn) < 10.e-15:
                    field_nn = 0.
        
                field_spec_n[nn, rr] = field_nn
            
        return field_spec_n

    def field_spec2phys(self, field_spec):

        '''
        transform a field in spectral space (i.e., f_n(r)) back to physical space
        we don't use this function in the gravity calculation, but it allows us to
        check that the spectral transformation is correct 
        : param u_spec:           field in spectral space; shape (max deg + 1, nr + 1)
        : return field_recons:    reconstructed field; shape (nt, nr + 1)
        '''

        field_recons = np.zeros([self.nt, self.nr + 1])

        for nn in range(self.leg_deg + 1):
            field_nn = np.outer(self.p[nn, :], field_spec[nn, :])
            field_recons = field_recons + field_nn

        return field_recons

    def calc_rho_prime(self):
        
        '''
        calculate density perturbation associated with zonal flow 
        : return rho_prime:   density perturbation; shape (nt, nr + 1) 
        '''

        # initialize matrix for density perturbation
        rho_prime = np.zeros([self.nt, self.nr + 1])

        # get background state
        rho0, drho0_dr, rho0_matrix, g_eff = self.background_state()

        # take spectral transformation of u_phi, for taking derivatives 
        u_phi_n = self.field_phys2spec(self.u_phi)

        # reverse order of theta grid (we integrate from 0 to theta_k)
        theta_rev = self.theta[::-1]

        # integrate
        for tt in np.arange(self.nt):
            # integral 1
            f_int1 = self.u_phi * np.cos(self.theta)[:, np.newaxis]
            f_int1_rev = f_int1[::-1]
            I1 = simps(f_int1_rev[0:tt+1], theta_rev[0:tt+1], axis=0) 

            # integral 2 & 3 (we take the derivatives in spectral space)     
            S_I2 = np.zeros([self.nt, self.nr + 1])
            S_I3 = np.zeros([self.nt, self.nr + 1])

            for nn in range(self.leg_deg + 1):
                Dm_u_phi_n = (1./self.L) * np.dot(self.Dm, u_phi_n[nn, :])
                S_I2_n = np.outer(self.p[nn, :], Dm_u_phi_n)                            # nt x nr + 1
                S_I3_n = np.outer(self.dp_dtheta[nn, :], u_phi_n[nn, :])

                S_I2 = S_I2 + S_I2_n
                S_I3 = S_I3 + S_I3_n

            f_int2 = S_I2 * np.cos(self.theta)[:, np.newaxis]
            f_int2_rev = f_int2[::-1] 
            I2 = simps(f_int2_rev[0:tt+1], theta_rev[0:tt+1], axis=0)

            f_int3 = S_I3 * np.sin(self.theta)[:, np.newaxis]
            f_int3_rev = f_int3[::-1]
            I3 = simps(f_int3_rev[0:tt+1], theta_rev[0:tt+1], axis=0)

            rho_prime[-tt-1, :] = 2. * self.Omega0 * (self.L * self.rcs) / g_eff * (drho0_dr * I1 + rho0 * I2 - rho0 * I3 / (self.L * self.rcs))

        return rho_prime

    def calc_Jns(self, rho_prime, Jn_max_deg = 15):
        
        '''
        calculate zonal gravity harmonics
        : param rho_prime:            numpy array containing the density perturbation associated
        :                             with the zonal wind profile; shape (nt, nr + 1)
        : param Jn_max_deg:           maximum degree zonal gravity harmonic to calculate
        : return J_ns, J_ns_equ:      numpy array containing the zonal gravity harmonics from degree 0
        :                             to Jn_max_deg; shape (1, Jn_max_deg + 1);
        :                             J_ns are normalized to the volumetric radius, J_ns_equ are normalized
        :                             to the equatorial radius
        '''

        # degrees for which we will calculate Jn
        arr_n = np.linspace(0, Jn_max_deg, Jn_max_deg + 1)

        # initialize array for the Jns
        J_ns = np.zeros(Jn_max_deg + 1)
        J_ns_equ = np.zeros(Jn_max_deg + 1)

        # calculate the Jns
        for nn in np.arange(Jn_max_deg + 1):
            Jn_sum = 0.
        
            for tt in np.arange(self.nt):
                for rr in np.arange(self.nr + 1):
                    Jn_grid = self.wr[rr] * self.w[tt] * 0.5 * (self.r_outer - self.r_inner) * rho_prime[tt, rr] * self.rcs[rr]**(nn + 2) * np.sqrt(1. - self.rc[rr]**2) * self.p[nn, tt] * np.sin(self.theta[tt]) / np.sin(self.theta[tt])
                    Jn_sum = Jn_sum + Jn_grid

            # Jn with respect to volumetric radius
            Jn = (-2. * np.pi * self.L**3 / self.M) * Jn_sum
            J_ns[nn] = Jn

            # Jn with to equatorial radius            
            J_ns_equ[nn] = Jn * (self.R_vol / self.a)**nn

        # organize results into table
        jns_matrix = np.zeros([Jn_max_deg + 1, 2])
        jns_matrix[:, 0] = arr_n
        jns_matrix[:, 1] = J_ns_equ / (10.**-8)

        if self.save_folder:
            #fmt = '\t'.join(['%10.5f']*2)
            fmt = '\t'.join(['%d', '%f'])
            h = '%10s\t%10s'%('Degree (n)', 'delta_Jn (* 10^-8)')
            np.savetxt(f'{self.save_folder}/data/jns', jns_matrix, fmt = fmt, header = h)
        
        return J_ns, J_ns_equ

